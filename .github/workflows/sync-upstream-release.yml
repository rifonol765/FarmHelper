# .github/workflows/sync-upstream-release.yml

name: Sync Upstream Release and Build

on:
  workflow_dispatch: # Allow manual triggering
  schedule:
    # Runs every hour
    - cron: '0 * * * *'

jobs:
  sync_and_build:
    runs-on: ubuntu-latest
    concurrency:
      group: ${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true

    steps:
      - name: Checkout Fork Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Keep fetch-depth: 0 to have history for merging
          token: ${{ secrets.GH_PAT }}

      - name: Set up Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Add Upstream Remote
        run: git remote add upstream https://github.com/JellyLabScripts/FarmHelper

      # --- MOVED STEPS: Determine tag name BEFORE fetching ---
      - name: Install GitHub CLI
        uses: github/hub@v2.14.2

      - name: Install jq (JSON Processor)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Get Latest Upstream Release Info
        id: upstream_release
        env:
          GH_TOKEN: ${{ github.token }}
          UPSTREAM_REPO: JellyLabScripts/FarmHelper
        run: |
          echo "Fetching latest release tag from $UPSTREAM_REPO..."
          latest_release_tag_json=$(gh release list --repo $UPSTREAM_REPO --limit 1 --json tagName)

          if [[ -z "$latest_release_tag_json" || "$latest_release_tag_json" == "[]" ]]; then
            echo "No releases found on upstream repository $UPSTREAM_REPO."
            echo "No new release found. Exiting cleanly."
            exit 0
          fi

          tag_name=$(echo "$latest_release_tag_json" | jq -r '.[0].tagName')

          if [[ -z "$tag_name" || "$tag_name" == "null" ]]; then
            echo "Could not extract tag name from the latest release listing."
            exit 1
          fi
          echo "Latest upstream tag found: $tag_name"
          echo "tag_name=$tag_name" >> $GITHUB_OUTPUT

          # Fetch full details *after* getting the tag name
          echo "Fetching details for tag $tag_name..."
          release_details_json=$(gh release view "$tag_name" --repo $UPSTREAM_REPO --json isPrerelease,name,body)

          if [[ -z "$release_details_json" ]]; then
             echo "Could not fetch details for release tag $tag_name."
             exit 1
          fi

          is_prerelease=$(echo "$release_details_json" | jq -r '.isPrerelease')
          release_name=$(echo "$release_details_json" | jq -r '.name')
          release_body=$(echo "$release_details_json" | jq -r '.body')

          echo "is_prerelease=$is_prerelease" >> $GITHUB_OUTPUT
          echo "release_name=$release_name" >> $GITHUB_OUTPUT
          echo "release_body<<EOF" >> $GITHUB_OUTPUT
          echo "$release_body" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Check if Release Exists in Fork for this Tag
        id: check_fork_release
        # This check uses the GitHub API, doesn't require the tag locally yet
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
          FORK_REPO: ${{ github.repository }}
          TAG_NAME: ${{ steps.upstream_release.outputs.tag_name }}
        run: |
          echo "Checking for existing release with tag '$TAG_NAME' in fork repository '$FORK_REPO'..."
          if gh release view "$TAG_NAME" --repo "$FORK_REPO" > /dev/null 2>&1; then
            echo "Release with tag '$TAG_NAME' already exists in the fork '$FORK_REPO'. Skipping."
            echo "skip=true" >> $GITHUB_OUTPUT
          else
            echo "Release with tag '$TAG_NAME' does not exist in the fork '$FORK_REPO'. Proceeding."
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      # --- MODIFIED FETCH STEP ---
      # Fetch ONLY the specific required tag and the master branch
      - name: Fetch Specific Upstream Tag and Master Branch
        # Only run if we determined we need to proceed
        if: steps.check_fork_release.outputs.skip == 'false'
        env:
          # Keep verbose flags just in case this specific fetch fails
          GIT_CURL_VERBOSE: 1
        run: |
          TARGET_TAG="${{ steps.upstream_release.outputs.tag_name }}"
          echo "Fetching specific tag '$TARGET_TAG' and branch 'master' from upstream..."
          # Fetch the tag using an explicit refspec
          # The refspec ensures the local tag name matches the remote one
          git fetch upstream "refs/tags/$TARGET_TAG:refs/tags/$TARGET_TAG" -v --progress --no-tags
          # Also fetch the master branch to ensure history for merge is available
          git fetch upstream master -v --progress --no-tags
          echo "Fetch command finished."
          # Verify tag was fetched locally
          git tag -l "$TARGET_TAG" || exit 1

      # --- Merge and Following Steps ---

      - name: Merge Upstream Tag
        if: steps.check_fork_release.outputs.skip == 'false'
        run: |
          DEFAULT_BRANCH=master
          git checkout $DEFAULT_BRANCH
          echo "Pulling latest changes from fork's origin $DEFAULT_BRANCH..."
          git pull origin $DEFAULT_BRANCH || { echo "Pull failed"; exit 1; } # Added error check
          echo "Attempting to merge upstream tag ${{ steps.upstream_release.outputs.tag_name }} into $DEFAULT_BRANCH..."
          # Now merge the tag ref that we specifically fetched
          git merge "refs/tags/${{ steps.upstream_release.outputs.tag_name }}" --no-ff -m "Merge upstream tag ${{ steps.upstream_release.outputs.tag_name }}" || {
            echo "Merge failed. Please resolve conflicts manually."
            exit 1
          }

      - name: Push Merge Commit
        if: steps.check_fork_release.outputs.skip == 'false'
        run: |
          DEFAULT_BRANCH=master
          echo "Pushing merge commit to origin/$DEFAULT_BRANCH..."
          git push origin $DEFAULT_BRANCH

      # --- Build Steps ---
      - uses: actions/setup-java@v4
        name: Setup Java
        if: steps.check_fork_release.outputs.skip == 'false'
        with:
          distribution: temurin
          java-version: 17

      - uses: gradle/actions/setup-gradle@v3
        name: Setup Gradle
        if: steps.check_fork_release.outputs.skip == 'false'

      - name: Execute Gradle build
        if: steps.check_fork_release.outputs.skip == 'false'
        run: ./gradlew build

      - name: List build artifacts # Keep this for verification
        if: steps.check_fork_release.outputs.skip == 'false'
        run: |
          echo "Listing contents of build/libs:"
          ls -l build/libs || echo "build/libs directory not found or empty."

      # --- Create Release ---
      - name: Create Fork Release
        if: steps.check_fork_release.outputs.skip == 'false'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.upstream_release.outputs.tag_name }}
          name: ${{ steps.upstream_release.outputs.release_name }}
          body: ${{ steps.upstream_release.outputs.release_body }}
          prerelease: ${{ steps.upstream_release.outputs.is_prerelease == 'true' }}
          files: | # Adjust this path if 'List build artifacts' shows something different
            build/libs/*.jar
          token: ${{ secrets.GH_PAT }}
